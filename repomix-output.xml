This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
eslint.config.mjs
memo.md
next.config.ts
package.json
postcss.config.mjs
prisma/migrations/20250422132044_init/migration.sql
prisma/migrations/migration_lock.toml
prisma/schema.prisma
prisma/seed.ts
public/file.svg
public/globe.svg
public/next.svg
public/vercel.svg
public/window.svg
README.md
scripts/export.ts
src/app/api/projects/[id]/route.ts
src/app/api/projects/route.ts
src/app/api/tasks/[id]/route.ts
src/app/api/tasks/notify-deadlines/route.ts
src/app/api/tasks/route.ts
src/app/globals.css
src/app/layout.tsx
src/app/page.tsx
src/components/KanbanBoard.tsx
src/components/ProjectManagerForm.tsx
src/components/TaskForm.tsx
src/lib/notifyTeams.ts
src/lib/notifyTriggers.ts
src/lib/prisma.ts
src/types.ts
tsconfig.json
tsconfig.seed.json
vercel.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="prisma/migrations/20250422132044_init/migration.sql">
-- CreateEnum
CREATE TYPE "Status" AS ENUM ('BACKLOG', 'TODO', 'ON_HOLD', 'IN_PROGRESS', 'REVIEW', 'DONE');

-- CreateTable
CREATE TABLE "Project" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "projectManager" TEXT NOT NULL,
    "webhookUrlKey" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Project_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Task" (
    "id" SERIAL NOT NULL,
    "projectId" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "dueDate" TIMESTAMP(3) NOT NULL,
    "assignee" TEXT NOT NULL,
    "tags" TEXT NOT NULL DEFAULT '',
    "status" "Status" NOT NULL DEFAULT 'TODO',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Task_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "Task" ADD CONSTRAINT "Task_projectId_fkey" FOREIGN KEY ("projectId") REFERENCES "Project"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="scripts/export.ts">
import { PrismaClient } from "@prisma/client";
import { writeFileSync } from "fs";

const prisma = new PrismaClient();

async function main() {
  const projects = await prisma.project.findMany({
    include: { tasks: true },
  });

  writeFileSync("data.json", JSON.stringify(projects, null, 2), "utf-8");
  console.log("âœ… data.json ã«ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãå‡ºã—ã¾ã—ãŸï¼");
}

main()
  .catch((e) => {
    console.error("âŒ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå¤±æ•—:", e);
  })
  .finally(() => {
    prisma.$disconnect();
  });
</file>

<file path="src/app/globals.css">
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
</file>

<file path="src/components/ProjectManagerForm.tsx">
// src/components/ProjectManagerForm.tsx
"use client";

import React, { useState } from "react";
import { Project } from "@/types";

type Props = {
  project: Project;
  onUpdated: (project: Project) => void;
};

export function ProjectManagerForm({ project, onUpdated }: Props) {
  const [isEditing, setIsEditing] = useState(false);
  const [manager, setManager] = useState(project.projectManager);

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    
    try {
      const res = await fetch(`/api/projects/${project.id}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ projectManager: manager }),
      });

      if (!res.ok) {
        throw new Error(await res.text());
      }

      const updated = await res.json();
      onUpdated(updated);
      setIsEditing(false);
    } catch (err) {
      console.error(err);
      alert("è²¬ä»»è€…ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ");
    }
  }

  if (!isEditing) {
    return (
      <div className="flex items-center gap-2">
        <span>è²¬ä»»è€…: {project.projectManager}</span>
        <button 
          onClick={() => setIsEditing(true)}
          className="px-2 py-1 text-sm bg-gray-100 hover:bg-gray-200 rounded"
        >
          ç·¨é›†
        </button>
      </div>
    );
  }

  return (
    <form onSubmit={handleSubmit} className="flex items-center gap-2">
      <input
        type="text"
        value={manager}
        onChange={e => setManager(e.target.value)}
        className="border p-1 rounded"
        required
      />
      <button
        type="submit"
        className="px-2 py-1 bg-blue-600 text-white rounded"
      >
        ä¿å­˜
      </button>
      <button
        type="button"
        onClick={() => {
          setManager(project.projectManager);
          setIsEditing(false);
        }}
        className="px-2 py-1 bg-gray-100 rounded"
      >
        ã‚­ãƒ£ãƒ³ã‚»ãƒ«
      </button>
    </form>
  );
}
</file>

<file path="src/types.ts">
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   src/types.ts       â€• å‹å®šç¾©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/** ã‚«ãƒ©ãƒ ï¼ˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼‰ */
export type Status =
  | 'BACKLOG'
  | 'TODO'        // â† æ—§UIãŒå‚ç…§ã—ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã®ã§æ®‹ã—ã¦ãŠã
  | 'ON_HOLD'
  | 'IN_PROGRESS'
  | 'REVIEW'
  | 'DONE';

/** ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ± */
export interface Project {
  /** ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ IDï¼ˆUUID æ–‡å­—åˆ—ãªã©ï¼‰ */
  id: string;
  /** è¡¨ç¤ºå */
  name: string;
  /** ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè²¬ä»»è€…ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ID or ãƒ¡ãƒ¼ãƒ«ï¼‰ */
  projectManager: string;
}

/** ã‚¿ã‚¹ã‚¯æƒ…å ± */
export interface Task {
  /** ã‚¿ã‚¹ã‚¯ IDï¼ˆæ•°å€¤ or UUIDï¼‰ */
  id: number;
  /** ã©ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«å±ã™ã‚‹ã‹ */
  projectId: string;
  /** ã‚¿ã‚¤ãƒˆãƒ« */
  title: string;
  /** æœŸæ—¥ï¼ˆISO æ–‡å­—åˆ—ï¼‰ */
  dueDate: string;
  /** æ‹…å½“è€…ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ID or ãƒ¡ãƒ¼ãƒ«ï¼‰ */
  assignee: string;
  /** ã‚¿ã‚°ï¼ãƒ¡ãƒ¢ãªã© */
  tags: string;
  /** ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ */
  status: Status;
}
</file>

<file path="vercel.json">
{
    "crons": [
      {
        "path": "/api/tasks/notify-deadlines",
        "schedule": "0 23 * * *"
      }
    ]
  }
</file>

<file path="memo.md">
## GitHubã¸ã®ä¿å­˜
git add .
git commit -m "ã‚³ãƒ¡ãƒ³ãƒˆ"
git push

## ãƒªãƒ¢ãƒ¼ãƒˆã®originã®æœ€æ–°ã®å¤‰æ›´ã‚’å–å¾—
git fetch origin

## origin/masterã®çŠ¶æ…‹ã«æˆ»ã™ï¼ˆãƒªãƒ¢ãƒ¼ãƒˆã®origin/masterã«æˆ»ã—ãŸã‘ã‚Œã°å…ˆã«fetch originï¼‰
git reset --hard origin/master

## ç¾åœ¨ã®ãƒ–ãƒ©ãƒ³ãƒã®ç¢ºèª
git branch

## ãƒ–ãƒ©ãƒ³ãƒã®ç§»å‹•
git chechout ãƒ–ãƒ©ãƒ³ãƒåï¼ˆã¾ãŸã¯ã‚³ãƒŸãƒƒãƒˆã®ãƒãƒƒã‚·ãƒ¥ï¼‰

## GitHubã‹ã‚‰ã®ã‚¯ãƒ­ãƒ¼ãƒ³
git clone https://github.com/ãƒ¦ãƒ¼ã‚¶ãƒ¼å/ãƒªãƒã‚¸ãƒˆãƒªå.git

## ãƒ‡ãƒ—ãƒ­ã‚¤ï¼ˆVercelã§ï¼‰

## ãƒ­ãƒ¼ã‚«ãƒ«ã§èµ·å‹•
npm run dev

## prisma studioèµ·å‹•
npx prisma studio

## ã‚³ãƒ¼ãƒ‰ã‚’1ãƒ•ã‚¡ã‚¤ãƒ«ã«ã¾ã¨ã‚ã‚‹
npx repomix
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="src/lib/prisma.ts">
import { PrismaClient } from '@prisma/client';

// Prevent multiple instances in development
const globalForPrisma = global as unknown as { prisma?: PrismaClient };
export const prisma =
  globalForPrisma.prisma ?? new PrismaClient();
if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}

export default prisma;

console.log("âœ… ç’°å¢ƒå¤‰æ•°:", process.env.DATABASE_URL);
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="tsconfig.seed.json">
{
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "lib": ["es6"],
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  }
}
</file>

<file path="next.config.ts">
// next.config.ts
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  // env ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯å‰Šé™¤ã€‚DEPLOY_URL ã¯ .env.local ã‹ã‚‰å–ã‚Šã¾ã™
};

export default nextConfig;
</file>

<file path="prisma/schema.prisma">
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  schema.prisma
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

/*â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  å…±é€š Enum
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”*/
enum Status {
  BACKLOG
  TODO
  ON_HOLD
  IN_PROGRESS
  REVIEW
  DONE
}

/*â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  Project  â† NEW
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”*/
model Project {
  id                String  @id @default(uuid())
  name              String
  projectManager    String      // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDãƒ»ãƒ¡ãƒ¼ãƒ«ãªã©
  webhookUrlKey     String?     // Teamsç”¨Webhook URLã®ç’°å¢ƒå¤‰æ•°ã‚­ãƒ¼å
  // 1:N Task
  tasks             Task[]

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

/*â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  Task  (Project ã«å±ã™ã‚‹)
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”*/
model Task {
  id        Int      @id @default(autoincrement())
  /* â€” ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ â€” */
  projectId String
  project   Project  @relation(fields: [projectId], references: [id])

  /* â€” æ—¢å­˜ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ â€” */
  title     String
  dueDate   DateTime
  assignee  String
  /**
   * ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Š or JSON æ–‡å­—åˆ—
   */
  tags      String   @default("")
  status    Status   @default(TODO)

  /* â€” ãƒ¡ã‚¿ â€” */
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
</file>

<file path="prisma/seed.ts">
import { PrismaClient } from '@prisma/client'
const prisma = new PrismaClient()

async function main() {
  // å–ã‚Šçµ„ã¿é›†ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
  const project1 = await prisma.project.create({
    data: {
      name: "å–ã‚Šçµ„ã¿é›†",
      projectManager: "éˆ´æœ¨PM",
      webhookUrlKey: "TORIKUMI_WEBHOOK_URL",
      tasks: {
        create: [
          {
            title: "æ©Ÿèƒ½Aï¼šè¨­è¨ˆ",
            dueDate: new Date("2025-05-01"),
            assignee: "ç”°ä¸­",
            status: "IN_PROGRESS",
            tags: "è¨­è¨ˆ,é‡è¦",
          },
          {
            title: "æ©Ÿèƒ½Bï¼šå®Ÿè£…",
            dueDate: new Date("2025-05-15"),
            assignee: "ä½è—¤",
            status: "TODO",
            tags: "å®Ÿè£…",
          },
          {
            title: "ãƒã‚°ä¿®æ­£",
            dueDate: new Date("2025-04-25"),
            assignee: "å±±ç”°",
            status: "REVIEW",
            tags: "ãƒã‚°,ç·Šæ€¥",
          }
        ]
      }
    },
  })

  // ã‚‚ã®ãŒãŸã‚Šãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
  const project2 = await prisma.project.create({
    data: {
      name: "ã‚‚ã®ãŒãŸã‚Š",
      projectManager: "ç”°ä¸­PM",
      webhookUrlKey: "MONOGATARI_WEBHOOK_URL",
      tasks: {
        create: [
          {
            title: "ä¼ç”»ç«‹æ¡ˆ",
            dueDate: new Date("2025-05-10"),
            assignee: "å±±ç”°",
            status: "IN_PROGRESS",
            tags: "ä¼ç”»,é‡è¦",
          },
          {
            title: "ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ãƒœãƒ¼ãƒ‰ä½œæˆ",
            dueDate: new Date("2025-05-20"),
            assignee: "ä½è—¤",
            status: "TODO",
            tags: "ãƒ‡ã‚¶ã‚¤ãƒ³",
          }
        ]
      }
    },
  })

  console.log("ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆã—ã¾ã—ãŸ:", {
    projects: [
      { id: project1.id, name: project1.name },
      { id: project2.id, name: project2.name }
    ]
  })
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })
</file>

<file path="src/lib/notifyTeams.ts">
// src/lib/notifyTeams.ts
import prisma from "./prisma";

/**
 * Microsoft Teams ã«ã‚«ãƒ¼ãƒ‰å½¢å¼ã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿ã™ã‚‹ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
 * @param projectId   ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆIDï¼ˆnull ã®å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® WEBHOOK_URL ã‚’ä½¿ç”¨ï¼‰
 * @param text        æŠ•ç¨¿ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æœ¬æ–‡
 */
export async function notifyTeams(
  projectId: string | null,
  text: string
): Promise<void> {
  let webhookUrl: string | null = null;

  // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã”ã¨ã« webhookUrlKey ã‚’ä½¿ã„åˆ†ã‘
  if (projectId) {
    const project = await prisma.project.findUnique({
      where: { id: projectId },
      select: { webhookUrlKey: true },
    });
    if (project?.webhookUrlKey) {
      webhookUrl = process.env[project.webhookUrlKey] || null;
    }
  }

  // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«è¨­å®šãŒãªã‘ã‚Œã°ç’°å¢ƒå¤‰æ•° TEAMS_WEBHOOK_URL ã‚’ä½¿ã†
  webhookUrl = webhookUrl || process.env.TEAMS_WEBHOOK_URL || null;

  if (!webhookUrl) {
    throw new Error(
      "Webhook URL ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ï¼ˆãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ or ç’°å¢ƒå¤‰æ•° TEAMS_WEBHOOK_URLï¼‰"
    );
  }

  console.log("Teams é€šçŸ¥é€ä¿¡:", { projectId, text });

  const res = await fetch(webhookUrl, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ text }),
  });

  if (!res.ok) {
    const body = await res.text();
    console.error("Teams é€šçŸ¥ã‚¨ãƒ©ãƒ¼:", res.status, body);
    throw new Error(`Teamsé€šçŸ¥ã«å¤±æ•—ã—ã¾ã—ãŸ (${res.status})`);
  }

  console.log("Teams é€šçŸ¥æˆåŠŸ");
}
</file>

<file path="src/lib/notifyTriggers.ts">
// src/lib/notifyTriggers.ts
import prisma from "./prisma";
import { notifyTeams } from "./notifyTeams";
import { Status, Task } from "@prisma/client";

/**
 * ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¤‰æ›´æ™‚ã® Teams é€šçŸ¥
 */
export async function notifyOnStatusChange(
  task: Task,
  beforeStatus?: Status
) {
  const assignee = task.assignee;
  const project = await prisma.project.findUnique({
    where: { id: task.projectId },
    select: { projectManager: true },
  });
  const manager = project?.projectManager;

  // ã“ã“ã ã‘ã‚’è¿”ã™
  const projectUrl = process.env.DEPLOY_URL!;

  if (task.status === "IN_PROGRESS" && beforeStatus !== "IN_PROGRESS") {
    await notifyTeams(
      task.projectId,
      `@${assignee}ã•ã‚“  
ã‚¿ã‚¹ã‚¯ã€Œ${task.title}ã€ãŒ In Progress ã«å…¥ã‚Šã¾ã—ãŸã€‚  
ğŸ”— ${projectUrl}`
    );
  }

  if (task.status === "REVIEW" && beforeStatus !== "REVIEW" && manager) {
    await notifyTeams(
      task.projectId,
      `@${manager}ã•ã‚“  
ã‚¿ã‚¹ã‚¯ã€Œ${task.title}ã€ãŒ Review ã«å…¥ã‚Šã¾ã—ãŸã€‚  
ğŸ”— ${projectUrl}`
    );
  }

  if (task.status === "DONE" && beforeStatus !== "DONE" && manager) {
    await notifyTeams(
      task.projectId,
      `@${assignee}ã•ã‚“ @${manager}ã•ã‚“  
ğŸ‰ ã‚¿ã‚¹ã‚¯ã€Œ${task.title}ã€ãŒå®Œäº†ã—ã¾ã—ãŸï¼ãŠã¤ã‹ã‚Œã•ã¾ã§ã—ãŸâœ¨  
ğŸ”— ${projectUrl}`
    );
  }
}
</file>

<file path="src/app/api/projects/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/prisma";

interface ProjectUpdateBody {
  projectManager: string;
}

export async function PATCH(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
): Promise<NextResponse> {
  const { id } = await params;

  try {
    const body = (await req.json()) as ProjectUpdateBody;

    if (!body.projectManager || typeof body.projectManager !== "string" || !body.projectManager.trim()) {
      return NextResponse.json({ error: "è²¬ä»»è€…ã¯å¿…é ˆã§ã™" }, { status: 400 });
    }

    const project = await prisma.project.update({
      where: { id },
      data: { projectManager: body.projectManager },
    });

    return NextResponse.json(project);
  } catch (error: unknown) {
    console.error("PATCH /api/projects/[id] ã‚¨ãƒ©ãƒ¼:", error);
    const message = error instanceof Error ? error.message : "ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼";
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
</file>

<file path="package.json">
{
  "name": "kanban-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "prisma generate && next build",
    "type-check": "tsc --noEmit",
    "start": "next start",
    "lint": "next lint",
    "db:seed": "npx ts-node prisma/seed.ts"
  },
  "dependencies": {
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/sortable": "^10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "@prisma/client": "^6.6.0",
    "next": "15.3.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20.17.30",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.3.1",
    "prisma": "^6.6.0",
    "tailwindcss": "^4",
    "ts-node": "^10.9.2",
    "typescript": "^5.8.3"
  },
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  }
}
</file>

<file path="src/app/api/tasks/notify-deadlines/route.ts">
// src/app/api/tasks/notify-deadlines/route.ts
import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { notifyTeams } from "@/lib/notifyTeams";

export const runtime = "nodejs";

/**
 * ç· åˆ‡ 3 æ—¥å‰ï¼å½“æ—¥é€šçŸ¥ç”¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * ãƒ»Cronï¼ˆVercel ã® crons æ©Ÿèƒ½ãªã©ï¼‰ã‹ã‚‰æ¯æ—¥ 1 å› GET ã•ã‚Œã‚‹æƒ³å®š
 * ãƒ»IN_PROGRESS ã®ã‚¿ã‚¹ã‚¯ã ã‘ã‚’å¯¾è±¡ã«é€šçŸ¥ã™ã‚‹ã‚ˆã†ã«å¤‰æ›´
 */
export async function GET(request: NextRequest) {
  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ æ—¥ä»˜ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const pad = (n: number) => String(n).padStart(2, "0");
  const formatYMD = (d: Date) =>
    `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}`;

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ "ä»Šæ—¥" ã‚’æ±ºå®š â”€â”€â”€â”€â”€â”€â”€â”€â”€
     ?today=yyyy-mm-dd ã‚’ä»˜ã‘ã‚‹ã¨ä»»æ„æ—¥ã§ãƒ†ã‚¹ãƒˆå¯ */
  const now = request.nextUrl.searchParams.get("today")
    ? (() => {
        const [Y, M, D] = request.nextUrl
          .searchParams.get("today")!
          .split("-")
          .map(Number);
        return new Date(Y, M - 1, D);
      })()
    : new Date();

  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const in3 = new Date(today);
  in3.setDate(in3.getDate() + 3);

  const todayStr = formatYMD(today);
  const in3Str = formatYMD(in3);

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ å½“æ—¥ã®ãƒ›ã‚¹ãƒˆåï¼ˆãƒªãƒ³ã‚¯ç”¨ï¼‰ â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const base = process.env.DEPLOY_URL!; // ä¾‹: https://example.vercel.app

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ å¯¾è±¡ã‚¿ã‚¹ã‚¯å–å¾— â”€â”€â”€â”€â”€â”€â”€â”€â”€
     è¿½åŠ æ¡ä»¶:  status = 'IN_PROGRESS' ã®ã¿æŠ½å‡º */
  const rawTasks = await prisma.$queryRaw<{
    id: number;
    title: string;
    dueDate: Date;
    assignee: string;
    projectId: string;
    projectManager: string | null;
  }[]>`
    SELECT t.id,
           t.title,
           t."dueDate",
           t.assignee,
           t."projectId",
           p."projectManager"
      FROM "Task" t
      JOIN "Project" p ON p.id = t."projectId"
     WHERE t."dueDate"::date IN (${todayStr}::date, ${in3Str}::date)
       AND t."status" IN ('IN_PROGRESS', 'ON_HOLD', 'REVIEW')
  `;

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ é€šçŸ¥é€ä¿¡ â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  for (const task of rawTasks) {
    const dueStr = formatYMD(task.dueDate);
    const projectUrl = base; // ç¾çŠ¶ã¯ãƒ«ãƒ¼ãƒˆã®ã¿

    if (dueStr === in3Str) {
      await notifyTeams(
        task.projectId,
        `@${task.assignee}ã•ã‚“  
ã‚¿ã‚¹ã‚¯ã€Œ${task.title}ã€ã®æœŸé™ã¾ã§ã‚ã¨3æ—¥ã§ã™ã€‚  
ğŸ”— ${projectUrl}`
      );
    } else if (dueStr === todayStr) {
      const mentions = task.projectManager
        ? `@${task.assignee}ã•ã‚“ @${task.projectManager}ã•ã‚“`
        : `@${task.assignee}ã•ã‚“`;
      await notifyTeams(
        task.projectId,
        `${mentions}  
ã‚¿ã‚¹ã‚¯ã€Œ${task.title}ã€ã®æœŸé™ã¯æœ¬æ—¥ã§ã™ã€‚  
ğŸ”— ${projectUrl}`
      );
    }
  }

  return NextResponse.json({ ok: true });
}
</file>

<file path="src/components/TaskForm.tsx">
// src/components/TaskForm.tsx
"use client";

import React, { useState } from "react";
import { Project, Task, Status } from "@/types";
import { ProjectManagerForm } from "./ProjectManagerForm";

type Props = {
  projects: Project[];
  projectId: string | null;
  setProjectId: (id: string | null) => void;

  /* ===== æ¥½è¦³çš„ UI ç”¨ ===== */
  onAdd: (task: Task) => void;                    // æ¥½è¦³è¿½åŠ 
  onCommit: (tempId: number, saved: Task) => void; // æ­£å¼åæ˜ 
  onRollback: (tempId: number) => void;            // å¤±æ•—ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯

  /* æ—¢å­˜ */
  onProjectUpdated: (project: Project) => void;
};

export function TaskForm({
  projects,
  projectId,
  setProjectId,
  onAdd,
  onCommit,
  onRollback,
  onProjectUpdated,
}: Props) {
  const [title, setTitle] = useState("");
  const [assignee, setAssignee] = useState("");
  const [dueDate, setDueDate] = useState("");
  const [tags, setTags] = useState("");
  const [isSaving, setSaving] = useState(false);

  const selectedProject = projects.find((p) => p.id === projectId) ?? null;

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ é€ä¿¡ â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    if (!projectId) {
      alert("ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„");
      return;
    }

    const tempId = -Date.now(); // è² æ•° IDï¼ä¸€æ„ãªãƒ†ãƒ³ãƒãƒ©ãƒª
    const optimisticTask: Task = {
      id: tempId,
      projectId,
      title,
      assignee,
      dueDate: new Date(dueDate).toISOString(),
      tags,
      status: "IN_PROGRESS" satisfies Status,
    };

    /* â‘  å…ˆã« UI ã¸åæ˜  */
    onAdd(optimisticTask);

    setSaving(true);
    try {
      const res = await fetch("/api/tasks", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          title,
          assignee,
          dueDate,
          tags,
          projectId,
        }),
      });
      if (!res.ok) throw new Error(await res.text());

      /* â‘¡ ã‚µãƒ¼ãƒãƒ¼ç¢ºå®š â†’ tempId ç½®æ› */
      const saved: Task = await res.json();
      onCommit(tempId, saved);

      /* å®Œäº† â†’ ãƒ•ã‚©ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ */
      setTitle("");
      setAssignee("");
      setTags("");
    } catch (err) {
      console.error(err);
      /* â‘¢ å¤±æ•— â†’ ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
      onRollback(tempId);
      alert("ã‚¿ã‚¹ã‚¯ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ");
    } finally {
      setSaving(false);
    }
  }

  return (
    <div className="mb-6">
      {/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆé¸æŠ & è²¬ä»»è€…ãƒ•ã‚©ãƒ¼ãƒ  â”€â”€â”€â”€â”€â”€â”€â”€â”€ */}
      <div className="flex gap-4 items-end mb-4">
        <div>
          <label className="block text-sm mb-1">ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ</label>
          <select
            value={projectId ?? ""}
            onChange={(e) =>
              setProjectId(e.target.value === "" ? null : e.target.value)
            }
            className="border p-2 rounded"
          >
            <option value="" disabled>
              -- ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’é¸æŠ --
            </option>
            {projects.map((p) => (
              <option key={p.id} value={p.id}>
                {p.name}
              </option>
            ))}
          </select>
        </div>

        {selectedProject && (
          <ProjectManagerForm
            project={selectedProject}
            onUpdated={onProjectUpdated}
          />
        )}
      </div>

      {/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ã‚¿ã‚¹ã‚¯å…¥åŠ›ãƒ•ã‚©ãƒ¼ãƒ  â”€â”€â”€â”€â”€â”€â”€â”€â”€ */}
      <form onSubmit={handleSubmit} className="flex flex-wrap gap-2">
        <input
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          placeholder="ã‚¿ã‚¹ã‚¯å"
          required
          className="border p-2 rounded"
        />
        <input
          value={assignee}
          onChange={(e) => setAssignee(e.target.value)}
          placeholder="æ‹…å½“è€…"
          required
          className="border p-2 rounded"
        />
        <input
          type="date"
          value={dueDate}
          onChange={(e) => setDueDate(e.target.value)}
          required
          className="border p-2 rounded"
        />
        <input
          value={tags}
          onChange={(e) => setTags(e.target.value)}
          placeholder="ã‚³ãƒ¡ãƒ³ãƒˆ"
          className="border p-2 rounded"
        />
        <button
          type="submit"
          disabled={isSaving}
          className="bg-blue-600 text-white px-3 py-2 rounded disabled:opacity-50"
        >
          {isSaving ? "ä¿å­˜ä¸­..." : "ä½œæˆ"}
        </button>
      </form>
    </div>
  );
}
</file>

<file path="src/app/api/tasks/route.ts">
// src/app/api/tasks/route.ts
import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { notifyOnStatusChange } from "@/lib/notifyTriggers";
import { Status } from "@prisma/client";

interface TaskCreateBody {
  title?: unknown;
  dueDate?: unknown;
  assignee?: unknown;
  tags?: unknown;
  status?: unknown;
  projectId?: unknown;
}

export async function GET(request: NextRequest): Promise<NextResponse> {
  try {
    const projectId = request.nextUrl.searchParams.get("projectId") ?? undefined;
    const tasks = await prisma.task.findMany({
      where: projectId ? { projectId } : undefined,
      orderBy: { dueDate: "asc" },
    });
    return NextResponse.json(tasks);
  } catch (error: unknown) {
    console.error("GET /api/tasks ã‚¨ãƒ©ãƒ¼:", error);
    return NextResponse.json(
      { error: "ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼" },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    const body = (await request.json()) as TaskCreateBody;

    // å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãƒã‚§ãƒƒã‚¯
    if (
      typeof body.title !== "string" ||
      typeof body.dueDate !== "string" ||
      typeof body.assignee !== "string" ||
      typeof body.projectId !== "string"
    ) {
      return NextResponse.json(
        { error: "title, dueDate, assignee, projectId ã¯å¿…é ˆã§ã™" },
        { status: 400 }
      );
    }

    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆæœŸå€¤
    let newStatus: Status = "IN_PROGRESS";
    if (
      typeof body.status === "string" &&
      Object.values(Status).includes(body.status as Status)
    ) {
      newStatus = body.status as Status;
    }

    // é‡è¤‡ãƒã‚§ãƒƒã‚¯
    const dup = await prisma.task.findFirst({
      where: {
        title: body.title,
        assignee: body.assignee,
        projectId: body.projectId,
      },
    });
    if (dup) {
      return NextResponse.json(
        { error: "åŒã˜ã‚¿ã‚¤ãƒˆãƒ«ï¼†æ‹…å½“è€…ã®ã‚¿ã‚¹ã‚¯ãŒæ—¢ã«å­˜åœ¨ã—ã¾ã™" },
        { status: 409 }
      );
    }

    // ã‚¿ã‚¹ã‚¯ä½œæˆ
    const task = await prisma.task.create({
      data: {
        title: body.title,
        dueDate: new Date(body.dueDate),
        assignee: body.assignee,
        tags: typeof body.tags === "string" ? body.tags : "",
        status: newStatus,
        projectId: body.projectId,
      },
    });

    // â‘  æ–°è¦ä½œæˆæ™‚ã‚‚ IN_PROGRESS é€šçŸ¥
    await notifyOnStatusChange(task);

    return NextResponse.json(task, { status: 201 });
  } catch (error: unknown) {
    console.error("POST /api/tasks ã‚¨ãƒ©ãƒ¼:", error);
    return NextResponse.json(
      { error: "ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/page.tsx">
// src/app/page.tsx
/* eslint-disable @next/next/no-img-element */
"use client";

import React, { useEffect, useState } from "react";
import { Project, Task } from "@/types";
import { TaskForm } from "@/components/TaskForm";
import { KanbanBoard } from "@/components/KanbanBoard";

export default function Home() {
  const [projects, setProjects] = useState<Project[]>([]);
  const [projectId, setProjectId] = useState<string | null>(null);
  const [tasks, setTasks] = useState<Task[]>([]);

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¸€è¦§ â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  useEffect(() => {
    fetch("/api/projects")
      .then((r) => r.json())
      .then(setProjects)
      .catch(console.error);
  }, []);

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ é¸æŠãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¿ã‚¹ã‚¯ â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  useEffect(() => {
    if (!projectId) {
      setTasks([]);
      return;
    }
    fetch(`/api/tasks?projectId=${projectId}`)
      .then((r) => r.json())
      .then(setTasks)
      .catch(console.error);
  }, [projectId]);

  /* ===== æ¥½è¦³çš„ UI ç”¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ===== */
  /** â‘  è¿½åŠ ï¼ˆtempId ã¯è² æ•°ã§ç™ºè¡Œï¼‰ */
  const addTaskOptimistic = (task: Task) =>
    setTasks((prev) => [...prev, task]);

  /** â‘¡ commit â†’ tempId ã‚’æ­£å¼ ID ã§ç½®æ› */
  const commitTask = (tempId: number, saved: Task) =>
    setTasks((prev) =>
      prev.map((t) => (t.id === tempId ? saved : t))
    );

  /** â‘¢ rollback â†’ tempId ã‚’é™¤å» */
  const rollbackTask = (tempId: number) =>
    setTasks((prev) => prev.filter((t) => t.id !== tempId));

  /** ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè²¬ä»»è€…ã®æ¥½è¦³æ›´æ–°ã¯ â€œã¨ã‚Šã‚ãˆãšâ€ å³æ™‚åæ˜ ã§ååˆ† */
  const handleProjectUpdated = (updated: Project) =>
    setProjects((prev) =>
      prev.map((p) => (p.id === updated.id ? updated : p))
    );

  return (
    <main className="p-4">
      <h1 className="text-2xl font-bold mb-4">Kanban Board</h1>

      <TaskForm
        /* â”€ props â”€ */
        projects={projects}
        projectId={projectId}
        setProjectId={setProjectId}
        /* æ¥½è¦³ UI ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
        onAdd={addTaskOptimistic}
        onCommit={commitTask}
        onRollback={rollbackTask}
        /* æ—¢å­˜ */
        onProjectUpdated={handleProjectUpdated}
      />

      <KanbanBoard tasks={tasks} setTasks={setTasks} />
    </main>
  );
}
</file>

<file path="src/components/KanbanBoard.tsx">
// src/components/KanbanBoard.tsx
"use client";

import React, { useState } from "react";
import {
  DndContext,
  DragEndEvent,
  MouseSensor,
  TouchSensor,
  useSensor,
  useSensors,
  useDroppable,
  useDraggable,
  rectIntersection,
} from "@dnd-kit/core";
import { Task, Status } from "@/types";

type KanbanBoardProps = {
  tasks: Task[];
  setTasks: React.Dispatch<React.SetStateAction<Task[]>>;
};

export function KanbanBoard({ tasks, setTasks }: KanbanBoardProps) {
  const sensors = useSensors(useSensor(MouseSensor), useSensor(TouchSensor));

  /* ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†æ™‚ â”€ æ¥½è¦³çš„ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–° */
  const handleDragEnd = async ({ active, over }: DragEndEvent) => {
    if (!over) return;
    const id = String(active.id).replace("task-", "");
    const newStatus = over.id as Status;
    const prev = tasks.find((t) => t.id === Number(id));
    if (!prev || prev.status === newStatus) return;

    setTasks((ts) =>
      ts.map((t) => (t.id === prev.id ? { ...t, status: newStatus } : t))
    );

    try {
      const res = await fetch(`/api/tasks/${id}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ status: newStatus }),
      });
      if (!res.ok) throw new Error();
    } catch {
      alert("æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ");
      setTasks((ts) => ts.map((t) => (t.id === prev.id ? prev : t)));
    }
  };

  const columns = [
    { key: "BACKLOG" as const, title: "Backlog" },
    { key: "ON_HOLD" as const, title: "On Hold" },
    { key: "IN_PROGRESS" as const, title: "In Progress" },
    { key: "REVIEW" as const, title: "Review" },
    { key: "DONE" as const, title: "Done" },
  ];

  return (
    <DndContext
      sensors={sensors}
      collisionDetection={rectIntersection}
      onDragEnd={handleDragEnd}
    >
      <div className="flex gap-4 overflow-x-auto pb-4">
        {columns.map((col) => (
          <Column
            key={col.key}
            column={col}
            tasks={tasks}
            setTasks={setTasks}
          />
        ))}
      </div>
    </DndContext>
  );
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Column â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
type ColumnProps = {
  column: { key: Status; title: string };
  tasks: Task[];
  setTasks: React.Dispatch<React.SetStateAction<Task[]>>;
};

function Column({ column, tasks, setTasks }: ColumnProps) {
  const { setNodeRef, isOver } = useDroppable({ id: column.key });

  return (
    <div
      ref={setNodeRef}
      className={`w-64 p-2 rounded min-h-[400px] border overflow-visible ${
        isOver
          ? "border-blue-500 bg-gray-100/80"
          : "border-gray-300 bg-gray-50/80"
      }`}
    >
      <h3 className="font-semibold mb-3">{column.title}</h3>
      <div className="space-y-2">
        {tasks
          .filter((t) => t.status === column.key)
          .map((task) => (
            <TaskCard key={task.id} task={task} setTasks={setTasks} />
          ))}
      </div>
    </div>
  );
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ TaskCard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
type TaskCardProps = {
  task: Task;
  setTasks: React.Dispatch<React.SetStateAction<Task[]>>;
};

function TaskCard({ task, setTasks }: TaskCardProps) {
  const [isEditing, setEditing] = useState(false);
  const [title, setTitle] = useState(task.title);
  const [assignee, setAssignee] = useState(task.assignee);
  const [dueDate, setDueDate] = useState(task.dueDate.split("T")[0]);
  const [tags, setTags] = useState(task.tags);
  const [isSaving, setSaving] = useState(false);

  const { attributes, listeners, setNodeRef, transform, isDragging } =
    useDraggable({ id: `task-${task.id}` });

  const style: React.CSSProperties = {
    transform: transform
      ? `translate3d(${transform.x}px, ${transform.y}px, 0)`
      : undefined,
    opacity: isDragging ? 0.5 : 1,
  };

  const stop = (e: React.PointerEvent) => e.stopPropagation();

  /* ä¿å­˜ï¼ˆæ¥½è¦³çš„ï¼‰ */
  const save = async (e: React.FormEvent) => {
    e.preventDefault();
    const optimistic: Task = {
      ...task,
      title,
      assignee,
      dueDate: new Date(dueDate).toISOString(),
      tags,
    };
    setTasks((ts) => ts.map((t) => (t.id === task.id ? optimistic : t)));
    setSaving(true);

    try {
      const res = await fetch(`/api/tasks/${task.id}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          title,
          assignee,
          dueDate: new Date(dueDate).toISOString(),
          tags,
        }),
      });
      if (!res.ok) throw new Error(await res.text());
      const saved: Task = await res.json();
      setTasks((ts) => ts.map((t) => (t.id === task.id ? saved : t)));
      setEditing(false);
    } catch (err) {
      console.error(err);
      setTasks((ts) => ts.map((t) => (t.id === task.id ? task : t)));
      alert("æ›´æ–°å¤±æ•—");
    } finally {
      setSaving(false);
    }
  };

  /* å‰Šé™¤ï¼ˆæ¥½è¦³çš„ï¼‰ */
  const remove = async () => {
    if (!confirm("ã“ã®ã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ")) return;
    setTasks((ts) => ts.filter((t) => t.id !== task.id));

    try {
      const res = await fetch(`/api/tasks/${task.id}`, { method: "DELETE" });
      if (!res.ok) throw new Error(await res.text());
    } catch (err) {
      console.error(err);
      setTasks((ts) => ts.concat(task));
      alert("å‰Šé™¤å¤±æ•—");
    }
  };

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ JSX â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  if (isEditing) {
    return (
      <form
        onSubmit={save}
        className="bg-white p-4 rounded shadow flex flex-col gap-2"
      >
        <input
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          placeholder="ã‚¿ã‚¤ãƒˆãƒ«"
          required
          className="border p-2 rounded w-full"
        />
        <input
          value={assignee}
          onChange={(e) => setAssignee(e.target.value)}
          placeholder="æ‹…å½“è€…"
          required
          className="border p-2 rounded w-full"
        />
        <input
          type="date"
          value={dueDate}
          onChange={(e) => setDueDate(e.target.value)}
          required
          className="border p-2 rounded w-full"
        />
        <input
          value={tags}
          onChange={(e) => setTags(e.target.value)}
          placeholder="ã‚³ãƒ¡ãƒ³ãƒˆ"
          className="border p-2 rounded w-full"
        />
        <div className="flex gap-2 mt-2">
          <button
            type="submit"
            disabled={isSaving}
            className="flex-1 bg-blue-600 text-white py-2 rounded hover:bg-blue-700 disabled:opacity-50"
          >
            {isSaving ? "ä¿å­˜ä¸­..." : "ä¿å­˜"}
          </button>
          <button
            type="button"
            onPointerDown={stop}
            onClick={() => setEditing(false)}
            className="flex-1 bg-gray-300 py-2 rounded hover:bg-gray-400"
          >
            ã‚­ãƒ£ãƒ³ã‚»ãƒ«
          </button>
        </div>
      </form>
    );
  }

  return (
    <div style={style} className="bg-white p-4 rounded shadow select-none">
      <div
        ref={setNodeRef}
        {...attributes}
        {...listeners}
        className="cursor-grab font-medium mb-2"
      >
        {task.title}
      </div>

      <div className="text-xs text-gray-600 mb-2">
        æœŸé™: {new Date(task.dueDate).toLocaleDateString()}
      </div>
      <div className="text-xs text-gray-600 mb-2">æ‹…å½“: {task.assignee}</div>
      {task.tags && (
        <div className="text-xs text-gray-600 mb-2 break-words">
          ã‚³ãƒ¡ãƒ³ãƒˆ: {task.tags}
        </div>
      )}

      <div className="flex gap-2 mt-2">
        <button
          onPointerDown={stop}
          onClick={() => setEditing(true)}
          className="px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded text-sm"
        >
          ç·¨é›†
        </button>
        <button
          onPointerDown={stop}
          onClick={remove}
          className="px-2 py-1 bg-red-100 hover:bg-red-200 rounded text-sm"
        >
          å‰Šé™¤
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/app/api/projects/route.ts">
// src/app/api/projects/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";

export async function GET(): Promise<NextResponse> {
  try {
    const projects = await prisma.project.findMany({
      orderBy: { name: "asc" },
    });
    return NextResponse.json(projects);
  } catch (error: unknown) {
    console.error("GET /api/projects ã‚¨ãƒ©ãƒ¼:", error);
    return NextResponse.json([], { status: 500 });
  }
}
</file>

<file path="src/app/api/tasks/[id]/route.ts">
// src/app/api/tasks/[id]/route.ts
import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { notifyOnStatusChange } from "@/lib/notifyTriggers";
import { notifyTeams } from "@/lib/notifyTeams";
import { Status } from "@prisma/client";

interface TaskUpdateBody {
  title?: string;
  dueDate?: string;
  assignee?: string;
  tags?: string;
  status?: string;
}

export async function PATCH(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
): Promise<NextResponse> {
  const { id } = await params;

  // 1. æ›´æ–°å‰ã®ã‚¿ã‚¹ã‚¯å–å¾—
  const before = await prisma.task.findUnique({
    where: { id: Number(id) },
    include: { project: true },
  });
  if (!before) {
    return NextResponse.json({ error: "ã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“" }, { status: 404 });
  }

  // 2. ãƒœãƒ‡ã‚£è§£æï¼‹æ›´æ–°ãƒ‡ãƒ¼ã‚¿çµ„ã¿ç«‹ã¦
  const body = (await req.json()) as TaskUpdateBody;
  const data: Partial<{
    title: string;
    dueDate: Date;
    assignee: string;
    tags: string;
    status: Status;
  }> = {};

  if (body.title) data.title = body.title;
  if (body.dueDate) data.dueDate = new Date(body.dueDate);
  if (body.assignee) data.assignee = body.assignee;
  if (body.tags) data.tags = body.tags;
  if (
    body.status &&
    Object.values(Status).includes(body.status as Status)
  ) {
    data.status = body.status as Status;
  }

  if (Object.keys(data).length === 0) {
    return NextResponse.json({ error: "æ›´æ–°é …ç›®ãŒã‚ã‚Šã¾ã›ã‚“" }, { status: 400 });
  }

  // 3. ã‚¿ã‚¹ã‚¯æ›´æ–°
  const after = await prisma.task.update({
    where: { id: Number(id) },
    data,
  });

  // 4. ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¤‰æ›´é€šçŸ¥
  await notifyOnStatusChange(after, before.status);

  // 5. ãã®ä»–ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å¤‰æ›´é€šçŸ¥
  const changes: string[] = [];
  if (data.title && data.title !== before.title) {
    changes.push(`ã‚¿ã‚¤ãƒˆãƒ«: "${before.title}" â†’ "${after.title}"`);
  }
  if (
    data.dueDate &&
    data.dueDate.getTime() !== before.dueDate.getTime()
  ) {
    const oldDate = before.dueDate.toISOString().slice(0, 10);
    const newDate = after.dueDate.toISOString().slice(0, 10);
    changes.push(`æœŸé™: ${oldDate} â†’ ${newDate}`);
  }
  if (data.assignee && data.assignee !== before.assignee) {
    changes.push(`æ‹…å½“è€…: ${before.assignee} â†’ ${after.assignee}`);
  }
  if (data.tags && data.tags !== before.tags) {
    changes.push(`ã‚¿ã‚°: "${before.tags}" â†’ "${after.tags}"`);
  }

  if (changes.length > 0) {
    // ã“ã“ã ã‘ DEPLOY_URL ã®ãƒ«ãƒ¼ãƒˆã‚’ä½¿ã†
    const projectUrl = process.env.DEPLOY_URL!;

    const text =
      `@${after.assignee}ã•ã‚“  
ã‚¿ã‚¹ã‚¯ã€Œ${after.title}ã€ã®æƒ…å ±ãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸ:\n` +
      changes.map((c) => `- ${c}`).join("\n") +
      `\n\nğŸ”— ${projectUrl}`;

    await notifyTeams(after.projectId, text);
  }

  return NextResponse.json(after);
}

export async function DELETE(
  _req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
): Promise<NextResponse> {
  const { id } = await params;
  const task = await prisma.task.findUnique({ where: { id: Number(id) } });
  if (!task) {
    return NextResponse.json({ error: "ã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“" }, { status: 404 });
  }
  await prisma.task.delete({ where: { id: Number(id) } });
  return new NextResponse(null, { status: 204 });
}
</file>

</files>
